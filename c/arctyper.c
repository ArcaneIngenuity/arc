#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ezxml/ezxml.h"

void implementTypesAndFunctions(FILE * hFile, const char * types[], int * typesCount, const char * functions[], int * functionsCount)
{
	fprintf(hFile, "// code generated by arctyper... //\n");
	
	fprintf(hFile, "#include \"arc.h\"\n");
	fprintf(hFile, "#include \"arctypes.h\"\n");
	fprintf(hFile, "#include <stdio.h>\n");
	fprintf(hFile, "#include <stdlib.h>\n");
	fprintf(hFile, "#include <string.h>\n");
	fprintf(hFile, "\n");
	
	for (int i = 0; i < *typesCount; ++i)
	{
		const char * type = types[i];
		fprintf(hFile, "#include \"%s.h\"\n", type);
	}
	fprintf(hFile, "\n");
	
	fprintf(hFile, "const char * TYPENAME[64];\n");
	fprintf(hFile, "size_t SIZEOF[64];\n");
	fprintf(hFile, "size_t sizeofCount = 0;\n");
	fprintf(hFile, "\n");
	
	fprintf(hFile, "void * addressofDynamic(const char * name)\n");
	fprintf(hFile, "{\n");
	fprintf(hFile, "\tif (strlen(name) > 0)\n");
	fprintf(hFile, "\t{\n");
	for (int i = 0; i < *functionsCount; ++i)
	{
		const char * function = functions[i];
		fprintf(hFile, "\t\tif (strcmp(name, \"%s\") == 0) return &%s;\n", function, function);
	}
	fprintf(hFile, "\t}\n");
	
	fprintf(hFile, "\tLOGI(\"function name not found: %%s.\\n\", name);\n");
	fprintf(hFile, "\texit(1);\n");
	
	fprintf(hFile, "}\n");
	fprintf(hFile, "\n");
	
	fprintf(hFile, "size_t sizeofDynamic(const char * name)\n");
	fprintf(hFile, "{\n");
	
	for (int i = 0; i < *typesCount; ++i)
	{
		const char * type = types[i];
		fprintf(hFile, "\tif (strcmp(name, \"%s\") == 0) return sizeof(%s);\n", type, type);
	}

	fprintf(hFile, "\tLOGI(\"type name not found: %%s.\\n\", name);\n");
	fprintf(hFile, "\texit(1);\n");
	fprintf(hFile, "}\n");
	
	fprintf(hFile, "// ...code generated by arctyper //\n");
}

void extractFunctionIfPresent(ezxml_t someXml, const char * functions[], int * functionsCount, const char * attrname)
{
	const char * handlername = ezxml_attr(someXml, attrname);
	if (handlername)
		if (strlen(handlername) > 0)
			functions[(*functionsCount)++] = handlername;
}

void extractFunctionsFrom(ezxml_t someXml, const char * functions[], int * functionsCount)
{
	//use the full collection of functions to check across all classes (many are shared)
	extractFunctionIfPresent(someXml, functions, functionsCount, "mustStart");
	extractFunctionIfPresent(someXml, functions, functionsCount, "mustStop");
	extractFunctionIfPresent(someXml, functions, functionsCount, "start");
	extractFunctionIfPresent(someXml, functions, functionsCount, "stop");
	extractFunctionIfPresent(someXml, functions, functionsCount, "initialise");
	extractFunctionIfPresent(someXml, functions, functionsCount, "dispose");
	extractFunctionIfPresent(someXml, functions, functionsCount, "update");
	extractFunctionIfPresent(someXml, functions, functionsCount, "updatePost");
	extractFunctionIfPresent(someXml, functions, functionsCount, "suspend");
	extractFunctionIfPresent(someXml, functions, functionsCount, "resume");
	extractFunctionIfPresent(someXml, functions, functionsCount, "onParentResize");
}

void recurseViews(ezxml_t viewXml, const char * types[], int * typesCount, const char * functions[], int * functionsCount)
{
	for (viewXml = ezxml_child(viewXml, "view"); viewXml; viewXml = viewXml->next)
	{
		types[(*typesCount)++] = ezxml_attr(viewXml, "class");
		extractFunctionsFrom(viewXml, functions, functionsCount);
		recurseViews(viewXml, types, typesCount, functions, functionsCount);
	}
}

void extractTypesAndFunctions(ezxml_t hubXml, const char * types[], int * typesCount, const char * functions[], int * functionsCount)
{
	ezxml_t appsXml = ezxml_child(hubXml, "apps");
	//const char * modelClass = ezxml_attr(modelXml, "class");
	
	for (ezxml_t appXml = ezxml_child(appsXml, "app"); appXml; appXml = appXml->next)
	{
		//app
		types[(*typesCount)++] = ezxml_attr(appXml, "class");
		extractFunctionsFrom(appXml, functions, functionsCount);
		
		//model
		ezxml_t modelXml = ezxml_child(appXml, "model");
		types[(*typesCount)++] = ezxml_attr(modelXml, "class");
		
		//ctrl
		ezxml_t ctrlXml = ezxml_child(appXml, "ctrl");
		types[(*typesCount)++] = ezxml_attr(ctrlXml, "class");
		extractFunctionsFrom(ctrlXml, functions, functionsCount);
	
		//views
		ezxml_t viewXml = ezxml_child(appXml, "view");
		types[(*typesCount)++] = ezxml_attr(viewXml, "class");
		extractFunctionsFrom(viewXml, functions, functionsCount);
		recurseViews(viewXml, types, typesCount, functions, functionsCount);
	}
}

void main(int argc, char *argv[])
{	
	if (argc < 2)
	{
		printf("Usage: arctyper <input: space-separated type names> <output>\n");
		printf("Output is <output>.c.\n");
		exit(1);
	}
	
	ezxml_t hubXml = ezxml_parse_file(argv[1]);
	if (hubXml == NULL)
	{
		printf("Error opening config file %s for read.\n", argv[1]);
		exit(1);
	}
	
	char * name = argv[2];
	char * suffix = ".c";
	char filename[strlen(name)+strlen(suffix)];
	strcpy(filename, name);
	strcat(filename, suffix);
	FILE * cFile = fopen(filename, "w");
	if (cFile == NULL)
	{
		printf("Error opening source file %s for write.\n", filename);
		exit(1);
	}
	
	//prepare types and functions arrays to be populated
	const char * types_[128];
	int typesCount_ = 0;
	const char * functions_[128];// = {"World_do", "Test_do"};
	int functionsCount_ = 0;
	
	extractTypesAndFunctions	(hubXml, types_, &typesCount_, functions_, &functionsCount_);
	implementTypesAndFunctions	(cFile,  types_, &typesCount_, functions_, &functionsCount_);
	
	ezxml_free(hubXml);
	if (cFile) fclose(cFile);
}