/// \copyright Copyright 2011-2015 N.P. Wiggill <nick.wiggill@gmail.com>. All rights reserved.
/// 
/// \license This project is released under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.
/// 
/// Permission is hereby granted, free of charge, to any person obtaining
/// a copy of this software and associated documentation files (the
/// "Software"), to deal in the Software without restriction, including
/// without limitation the rights to use, copy, modify, merge, publish,
/// distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to
/// the following conditions:
/// 
/// The above copyright notice and this permission notice shall be included
/// in all copies or substantial portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
/// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
/// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
/// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
/// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///
/// \brief arc - a realtime applications framework for native & web

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ezxml/ezxml.h"
#include "arc.h" //DEV - for ezxml_child_any()

static char * srcPath;

char* Text_load(char* filename) //as from orb 10/13/2015
{
	//should be portable - http://stackoverflow.com/questions/14002954/c-programming-how-to-read-the-whole-file-contents-into-a-buffer
	
	char * str;

	FILE *file = fopen(filename, "rb"); //open for reading
	if (file)
	{
		fseek(file, 0, SEEK_END); //seek to end
		long fileSize = ftell(file); //get current position in stream
		fseek(file, 0, SEEK_SET); //seek to start
		LOGI("%s\n", filename);
		
		str = malloc(fileSize + 1); //allocate enough room for file + null terminator (\0)

		if (str != NULL) //if allocation succeeded
		{
			
			//LOGI(" (fileSize...%ld)\n", fileSize);
			size_t freadResult;
			freadResult = fread(str, 1, fileSize, file); //read elements as one byte each, into string, from file. 
			//LOGI("freadResult...%d\n", freadResult);
			
			if (freadResult != fileSize)
			{
				fputs ("Reading error", stderr);
				//exit (3);
				
				str = NULL;
				return str;
			}
			
			fclose(file);

			str[fileSize] = 0; //'\0';
		}
	}
	else
		LOGI("File not found: %s", filename);
	
	return str;
}

void implementTypesAndFunctions(FILE * hFile, const char * types[], int * typesCount, const char * functions[], int * functionsCount)
{
	fprintf(hFile, "// code generated by arctyper... //\n");
	
	fprintf(hFile, "#include \"arc.h\"\n");
	fprintf(hFile, "#include \"arctypes.h\"\n");
	fprintf(hFile, "#include <stdio.h>\n");
	fprintf(hFile, "#include <stdlib.h>\n");
	fprintf(hFile, "#include <string.h>\n");
	fprintf(hFile, "\n");
	
	for (int i = 0; i < *typesCount; ++i)
	{
		const char * type = types[i];
		fprintf(hFile, "#include \"%s.h\"\n", type);
	}
	fprintf(hFile, "\n");
	
	fprintf(hFile, "const char * TYPENAME[64];\n");
	fprintf(hFile, "size_t SIZEOF[64];\n");
	fprintf(hFile, "size_t sizeofCount = 0;\n");
	fprintf(hFile, "\n");
	
	fprintf(hFile, "void * addressofDynamic(const char * name)\n");
	fprintf(hFile, "{\n");
	fprintf(hFile, "\tif (strlen(name) > 0)\n");
	fprintf(hFile, "\t{\n");
	for (int i = 0; i < *functionsCount; ++i)
	{
		const char * function = functions[i];
		fprintf(hFile, "\t\tif (strcmp(name, \"%s\") == 0) return &%s;\n", function, function);
	}
	fprintf(hFile, "\t}\n");
	
	fprintf(hFile, "\tLOGI(\"[ARC] Function name not found: %%s.\\n\", name);\n");
	fprintf(hFile, "\texit(1);\n");
	
	fprintf(hFile, "}\n");
	fprintf(hFile, "\n");
	
	fprintf(hFile, "size_t sizeofDynamic(const char * name)\n");
	fprintf(hFile, "{\n");
	
	for (int i = 0; i < *typesCount; ++i)
	{
		const char * type = types[i];
		fprintf(hFile, "\tif (strcmp(name, \"%s\") == 0) return sizeof(%s);\n", type, type);
	}

	fprintf(hFile, "\tLOGI(\"[ARC] Class name not found: %%s.\\n\", name);\n");
	fprintf(hFile, "\treturn NULL;\n");
	fprintf(hFile, "}\n");
	
	fprintf(hFile, "// ...code generated by arctyper //\n");
}

void extractFunctionFromConfigXML(ezxml_t someXml, const char * functions[], int * functionsCount, const char * attrname)
{
	const char * handlername = ezxml_attr(someXml, attrname);
	if (handlername)
		if (strlen(handlername) > 0)
			functions[(*functionsCount)++] = handlername;
}

void extractFunctionsFromConfigXML(ezxml_t someXml, const char * functions[], int * functionsCount)
{
	//use the full collection of functions to check across all classes (many are shared)
	//extractFunctionFromConfigXML(someXml, functions, functionsCount, "mustStart");
	//extractFunctionFromConfigXML(someXml, functions, functionsCount, "mustStop");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "start");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "stop");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "initialise");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "dispose");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "update");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "updatePost");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "suspend");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "resume");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "onParentResize");
	extractFunctionFromConfigXML(someXml, functions, functionsCount, "fromConfigXML");
}

void stripBlockComments(char * buffer)
{
	char current;
	char last = 0;
	char * lastPtr = NULL;
	
	int c  = 0;
	
	bool inBlockComment = false;
	while (buffer[0] != '\0')
	{
		current = buffer[0];
		if 		(last == '/' && current == '*')
		{
			inBlockComment = true;
			lastPtr[0] = ' ';
		}
		else if (last == '*' && current == '/')
		{
			inBlockComment = false;
			buffer[0] = ' ';
			lastPtr[0] = ' ';
		}			
		
		if (inBlockComment)
		{
			buffer[0] = ' ';
		}
			
		last = current;
		lastPtr = buffer;
		++buffer;
	}
}

void stripLineComments(char * buffer)
{
	char current;
	char last = 0;
	char * lastPtr = NULL;
	
	int c  = 0;
	
	bool inElement = false;
	while (buffer[0] != '\0')
	{
		current = buffer[0];
		if 	(current == '/')
		{
			if (last == '/')
			{
				inElement = true;
				lastPtr[0] = ' ';
			}
		}
		else if (current == '\n')
		{
			inElement = false;
		}			
		
		if (inElement)
		{
			buffer[0] = ' ';
		}
			
		last = current;
		lastPtr = buffer;
		++buffer;
	}
}

void stripPreprocessorDirectives(char * buffer)
{
	//char *strchr(const char *string, int c) -- Find first occurrence of character c in string. 
	int c  = 0;
	//char * str;
	
	//str = strchr(fileString, '#');
	
	bool inElement = false;//str[0] == '#';
	bool inMultiline = false;
	while (buffer[0] != '\0')
	{
		//++str;
		
		if (buffer[0] == '#')
		{
			inElement = true;
		}
		
		if (inElement)
		{
			if (buffer[0] == '\\')
				inMultiline = true;
			
			if (buffer[0] == '\n')
			{
				if (inMultiline)
				{
					inMultiline = false; //until such time as it may(!) be proven true again at end of this line
				}
				else //ordinary case - just end the preprocessor directive.
				{
					inElement = false;
					continue; //we don't want the newline included
				}
			}
		}
		
		if (inElement)
			buffer[0] = ' ';
		/*
		{
			buffer[c++] = fileString[0];
		}
		*/
		++buffer;
	}
}


void stripTypedefs(char * buffer)
{
	char current;
	char last = 0;
	
	int c  = 0;
	
	//use of 8 = length of "typedef" + space
	char* bufferLastFew;

	int braceCount = 0;
	
	bool inElement = false;
	while (buffer[0] != '\0')
	{
		current = buffer[0];
		if (c >= 8)
		{
			bufferLastFew = buffer - 8;
			//LOGI("???%s|", bufferLastFew);
			//if (bufferLastFew[0] == 't') exit(1);
			if (strncmp(bufferLastFew, "typedef ", 8) == 0)
			{
				inElement = true;
				for (int i = 0; i < 8; ++i)
				{
					bufferLastFew[i] = ' ';
				}
			}
			
			if (inElement)
			{
				if (buffer[0] == '{')
					++braceCount;
				if (buffer[0] == '}')
					--braceCount;
				
				if (braceCount == 0 && current == ';') //this isn't necessarily safe, but should work for vast majority of cases
				{
					inElement = false;
				}
				buffer[0] = ' ';
			}
		}
		
		last = current;
		
		++buffer;
		++c;
	}
}
void newlinesAndTabsToSpaces(char * buffer)
{
	while (buffer[0] != '\0')
	{
		if (buffer[0] == '\r' ||
			buffer[0] == '\n' ||
			buffer[0] == '\t')
		{
			buffer[0] = ' ';
		}

		++buffer;
	}	
}

int countValidEntries(char * buffer)
{
	int c = 0;
	bool inElement = false;
	while (buffer[0] != '\0')
	{
		if (inElement)
		{
			if (buffer[0] == ';')
				inElement = false;
		}
		else //not in element
		{
			if (buffer[0] != ' ')
			{
				inElement = true;
				++c;
			}
		}

		++buffer;
	}
	
	return c;
}

void getFunctionDeclarations(char * buffer, char ** results)
{
	int r = 0; //result index
	bool inElement = false;
	while (buffer[0] != '\0')
	{
		if (inElement)
		{
			if (buffer[0] == ';')
			{
				inElement = false;
				buffer[0] = '\0'; //replace semicolon with null - safer than placing beyond - to terminate each result string.
			}
		}
		else //not in element
		{
			if (buffer[0] != ' ')
			{
				inElement = true;
				results[r++] = buffer;
			}
		}

		++buffer;
	}
}

void getFunctionName(char * buffer, char ** namePtr)
{
	while (buffer[0] != '\0')
	{
		if (buffer[0] == '(') //opening bracket of function declaration
		{
			
			//seek backwards until space found
			--buffer;
			while (buffer[0] == ' ') //walk any empty space between function name and (
			{
				--buffer;
			}
			buffer[1] = '\0'; //terminate here at word end in last space
			while (buffer[0] != ' ') //walk any empty space between function name and (
			{
				--buffer;
			}
			//set pointer to word start
			*namePtr = buffer + 1;
			return;
		}

		++buffer;
	}	
}


void extractFunctionsFromHeaders(const char * types[], int * typesCount, const char * functions[], int * functionsCount)
{	
	char filename[256];
	strcpy(filename, srcPath);
	strcat(filename, "/");
	strcat(filename, types[(*typesCount-1)]); // for the most recently added type
	strcat(filename, ".h");
	char * fileString = Text_load(filename); //NB not freed till program ends - thus we keep valid strings till implementTypesAndFunctions()
	LOGI("---------------------------\n");
	//LOGI("fileString=%s\n", fileString);
	//char buffer[strlen(fileString)];
	//strcpy(buffer, fileString);
	stripPreprocessorDirectives	(fileString);
	stripBlockComments			(fileString);
	stripLineComments			(fileString);
	stripTypedefs				(fileString);
	newlinesAndTabsToSpaces		(fileString);
	
	int c = countValidEntries(fileString);
	char * declarations[c];
	getFunctionDeclarations(fileString, declarations);
	
	char * functionNames[c];
	
	//LOGI("count of functions = %d", c);
	for (int i = 0; i < c; ++i)
	{
		getFunctionName(declarations[i], &functionNames[i]);
		//removeRedundantSpacesFromElement(declarations[i]);
		//LOGI("(decl) %d | %s\n", i, declarations[i]);
		functions[(*functionsCount)++] = functionNames[i];
		LOGI("%2d | %s\n", i, functionNames[i]);
		
	}
	
	LOGI("---------------------------\n");
}

void extractTypesAndFunctionsFromExtensionsXML(ezxml_t parentXml, const char * types[], int * typesCount, const char * functions[], int * functionsCount)
{
	for (ezxml_t elementXml = ezxml_child_any(parentXml); elementXml; elementXml = elementXml->sibling) //run through distinct child element names
	{
		bool allowCustomElementsAsExtensions = false; //DEV -get from <hub> as an arg (or pass hub as arg)
		if (allowCustomElementsAsExtensions)
		{
			//TODO similar to below block, but using a custom element name as extension class name
		}
		else //do not allow custom elements - fallback to seeking standard <extension> elements
		{
			if (strcmp(ezxml_name(elementXml), "extension") == 0) 
			{
				ezxml_t elementXmlCopy = elementXml;
				while (elementXmlCopy) //iterate over child elements of same name (that sit adjacent?)
				{
					types[(*typesCount)++] = ezxml_attr(elementXmlCopy, "class");
					extractFunctionsFromHeaders(types, typesCount, functions, functionsCount);
					elementXmlCopy = elementXmlCopy->next;
				}
				
			}
		}
	}
}

void recurseViews(ezxml_t viewXml, const char * types[], int * typesCount, const char * functions[], int * functionsCount)
{
	for (viewXml = ezxml_child(viewXml, "view"); viewXml; viewXml = viewXml->next)
	{
		types[(*typesCount)++] = ezxml_attr(viewXml, "class");
		//extractFunctionsFromConfigXML(viewXml, functions, functionsCount);
		extractFunctionsFromHeaders(types, typesCount, functions, functionsCount);
		extractTypesAndFunctionsFromExtensionsXML(viewXml, types, typesCount, functions, functionsCount);
		recurseViews(viewXml, types, typesCount, functions, functionsCount);
	}
}

void extractTypesAndFunctionsFromConfigXML(ezxml_t hubXml, const char * types[], int * typesCount, const char * functions[], int * functionsCount)
{
	ezxml_t appsXml = ezxml_child(hubXml, "apps");
	//const char * modelClass = ezxml_attr(modelXml, "class");
	
	for (ezxml_t appXml = ezxml_child(appsXml, "app"); appXml; appXml = appXml->next)
	{
		//app
		types[(*typesCount)++] = ezxml_attr(appXml, "class");
		//extractFunctionsFromConfigXML(appXml, functions, functionsCount);
		extractFunctionsFromHeaders(types, typesCount, functions, functionsCount);
		
		//model
		ezxml_t modelXml = ezxml_child(appXml, "model");
		types[(*typesCount)++] = ezxml_attr(modelXml, "class");
		
		//ctrl
		ezxml_t ctrlXml = ezxml_child(appXml, "ctrl");
		types[(*typesCount)++] = ezxml_attr(ctrlXml, "class");
		//extractFunctionsFromConfigXML(ctrlXml, functions, functionsCount);
		extractFunctionsFromHeaders(types, typesCount, functions, functionsCount);
		extractTypesAndFunctionsFromExtensionsXML(ctrlXml, types, typesCount, functions, functionsCount);
	
		//views
		ezxml_t viewXml = ezxml_child(appXml, "view");
		types[(*typesCount)++] = ezxml_attr(viewXml, "class");
		//extractFunctionsFromConfigXML(viewXml, functions, functionsCount);
		extractFunctionsFromHeaders(types, typesCount, functions, functionsCount);
		extractTypesAndFunctionsFromExtensionsXML(viewXml, types, typesCount, functions, functionsCount);
		recurseViews(viewXml, types, typesCount, functions, functionsCount);
	}
}

void main(int argc, char *argv[])
{	
	if (argc < 2)
	{
		printf("Usage: arctyper <input: space-separated type names> <output>\n");
		printf("Output is <output>.c.\n");
		exit(1);
	}
	
	ezxml_t hubXml = ezxml_parse_file(argv[1]);
	if (hubXml == NULL)
	{
		printf("Error opening config file %s for read.\n", argv[1]);
		exit(1);
	}
	
	srcPath = argv[2];
	
	char * name = argv[3];
	char * suffix = ".c";
	char filename[strlen(name)+strlen(suffix)];
	strcpy(filename, name);
	strcat(filename, suffix);
	FILE * cFile = fopen(filename, "w");
	if (cFile == NULL)
	{
		printf("Error opening source file %s for write.\n", filename);
		exit(1);
	}
	
	//prepare types and functions arrays to be populated
	const char * types_[128];
	int typesCount_ = 0;
	const char * functions_[128];// = {"World_do", "Test_do"};
	int functionsCount_ = 0;
	
	extractTypesAndFunctionsFromConfigXML(hubXml, types_, &typesCount_, functions_, &functionsCount_);
	implementTypesAndFunctions			 (cFile,  types_, &typesCount_, functions_, &functionsCount_);
	
	ezxml_free(hubXml);
	if (cFile) fclose(cFile);
}